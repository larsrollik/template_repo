# Description: This workflow is triggered when a pull request is closed and merged into the `main` branch.
name: PR into main -> Squash Merge to Prod

on:
  pull_request:
    branches:
      - main   # Trigger only on PRs targeting the `main` branch
    types:
      - closed # Run only when a PR is closed


jobs:
  squash_merge_to_prod:
    runs-on: ubuntu-latest
    if: github.event.pull_request.merged == true

    steps:
      # Step 1: Checkout Repository
      - name: Checkout Repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      # Step 2: Configure Git
      - name: Configure Git
        run: |
          git config user.name "${{ github.actor }}"
          git config user.email "${{ github.actor }}@users.noreply.github.com"

      # Step 3: Checkout or Create Prod Branch
      - name: Checkout Prod Branch
        run: |
          git fetch origin prod || echo "Prod branch does not exist. Initializing."
          git checkout prod || git checkout --orphan prod
          git pull origin prod || echo "No existing history to pull."
          git push origin prod --set-upstream

      # Step 4: Generate Commit Message for Squash Merge
      - name: Generate Commit Message
        id: commit_message
        run: |
          # Get the feature branch name from the pull request
          FEATURE_BRANCH="${{ github.event.pull_request.head.ref }}"

          # Collect the commits from the feature branch merged into `main`
          NEW_COMMITS=$(git log main --merges --grep="${FEATURE_BRANCH}" --oneline)
          if [ -z "$NEW_COMMITS" ]; then
            echo "No new commits to squash merge. Exiting."
            exit 0
          fi

          # Create a structured commit message
          COMMIT_MSG="From '${FEATURE_BRANCH}':\n\n$(git log --format='- %s' main..HEAD)"

          # Set commit message as environment variable
          echo "COMMIT_MSG=${COMMIT_MSG}" >> $GITHUB_ENV

#      # Step 5: Perform Squash Merge with Conflict Resolution
#      - name: Perform Squash Merge
#        run: |
#          git fetch origin main
#          git merge -X theirs main  # Regular merge with 'theirs' strategy to resolve conflicts
#          git merge --squash main  # Perform squash after resolving conflicts
#          git commit -m "${{ env.COMMIT_MSG }}"  # Use the commit message from the previous step
#
#      # Step 6: Push Squashed Commit to Prod
#      - name: Push to Prod Branch
#        run: |
#          git push origin prod

      # Step 5: Perform Squash and Resolve Conflicts in Favor of Main
      - name: Perform Squash and Resolve Conflicts in Favor of Main
        run: |
          # Fetch the latest changes from 'main'
          git fetch origin main

          # Squash the commits from 'main' into a single commit
          git merge --squash main

          # Resolve conflicts automatically in favor of 'main'
          git merge -X theirs main

          # Create a commit message summarizing the commit messages
          FEATURE_BRANCH="${{ github.event.pull_request.head.ref }}"
          NEW_COMMITS=$(git log main --merges --grep="${FEATURE_BRANCH}" --oneline)
          if [ -z "$NEW_COMMITS" ]; then
            echo "No new commits to squash merge. Exiting."
            exit 0
          fi

          COMMIT_MSG="Squashed changes from '${FEATURE_BRANCH}':\n\n$(git log --format='- %s' main..HEAD)"

          # Write commit message to GitHub environment to use it in the next step
          echo "COMMIT_MSG=${COMMIT_MSG}" >> $GITHUB_ENV

          # Commit the squashed changes
          git commit -m "${{ env.COMMIT_MSG }}"  # Use the commit message from the previous step

          # Push the changes to the 'prod' branch
          git push origin prod
